<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>D3 Graph</title>
    <style>
        svg {
            border: 1px solid black;
        }
    </style>
</head>
<body>
<svg width="800" height="800"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-collection.v1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-format.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale.v2.min.js"></script>

<script>
    var nodesData = [
        {
            "key": "A_my",
            "authors": "A et al.",
            "title": "My first paper",
            "date-created": "2018-09-01",
            "referenced-n-times-global": 0,
            "referenced-n-times-local": 0,
            "year": 2
        },
        {
            "key": "B_friendly",
            "authors": "B et al.",
            "title": "Friendly paper",
            "date-created": "2018-04-23",
            "referenced-n-times-global": 5,
            "referenced-n-times-local": 0,
            "year": 2
        },
        {
            "key": "F_young",
            "authors": "F et al.",
            "title": "Young paper",
            "date-created": "2016-02-16",
            "referenced-n-times-global": 37,
            "referenced-n-times-local": 1,
            "year": 1
        },
        {
            "key": "C_another",
            "authors": "C et al.",
            "title": "Another friendly paper",
            "date-created": "2016-12-05",
            "referenced-n-times-global": 8,
            "referenced-n-times-local": 0,
            "year": 1
        },
        {
            "key": "D_old",
            "authors": "D et al.",
            "title": "Old paper",
            "date-created": "2013-04-01",
            "referenced-n-times-global": 236,
            "referenced-n-times-local": 2,
            "year": 0
        },
        {
            "key": "E_older",
            "authors": "E et al.",
            "title": "Older paper",
            "date-created": "2012-08-13",
            "referenced-n-times-global": 412,
            "referenced-n-times-local": 1,
            "year": 0
        }
    ];

    var linksData = [
        {"source": "A_my", "target": "D_old"},
        {"source": "B_friendly", "target": "D_old"},
        {"source": "B_friendly", "target": "E_older"},
        {"source": "C_another", "target": "F_young"},
    ];

    var minimumReferencedGlobal = Math.min.apply(Math, nodesData.map(p => p["referenced-n-times-global"]));
    var maximumReferencedGlobal = Math.max.apply(Math, nodesData.map(p => p["referenced-n-times-global"]));
    var minimumReferencedLocal = Math.min.apply(Math, nodesData.map(p => p["referenced-n-times-local"]));
    var maximumReferencedLocal = Math.max.apply(Math, nodesData.map(p => p["referenced-n-times-local"]));
    var nYears = Math.max.apply(Math, nodesData.map(p => p["year"])) + 1;

    var minimumRadius = 50,
        maximumRadius = 20,
        colorMin = "white",
        colorMax = "#9C27B0",
        maxTitleLength = 20,
        collisionRadius = 100,
        labelFontSizePixels = 20,
        labelFontSizeString = labelFontSizePixels + "px",
        defaultTextOpacity = 0.85,
        defaultStrokeOpacity = 0.5
    ;

    var radiusScale = d3.scaleLog()
        .domain([minimumReferencedGlobal + 1, maximumReferencedGlobal + 1]) // must not be zero => + 1
        .range([minimumRadius, maximumRadius]);

    var colorScale = d3.scaleLinear()
        .domain([minimumReferencedLocal, maximumReferencedLocal])
        .range([colorMin, colorMax]);

    var shadowColorScale = d3.scaleLinear()
        .domain([minimumReferencedLocal, maximumReferencedLocal])
        .range(["black", colorMax]);

    nodesData.forEach(p => p.radius = radiusScale(p["referenced-n-times-global"] + 1));

    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");
    var defs = svg.append('defs');

    var yearHeight = height / nYears;

    var force = d3
        .forceSimulation()
        .nodes(nodesData)
        .alpha(0.25)
        .alphaMin(0.05)
        .on('end', function () {
            force.force("collision_force", null);
            force.force("position_force_Y", null);
            force.force("position_force_X", null);
            force.force("link_force", null);
        })
    ;

    force
        .force("collision_force", d3.forceCollide(collisionRadius).strength(1))
        .force("link_force", d3.forceLink(linksData).id(d => d.key).strength(0.1))
        .force("position_force_Y", d3.forceY(d => yearHeight * (d.year + 0.5)).strength(3))
        .force("position_force_X", d3.forceX(width / 2).strength(0.2))
    ;

    var link = svg
        .append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(linksData)
        .enter()
        .append("g")
        .on('mouseover', fadeLink(0.5, 0.1, 0.5, 0.25, true))
        .on('mouseout', fadeLink(1.0, 1.0, 1.0, 1.0, false))
    ;

    var visibleLink = link
        .append("line")
        .attr("stroke-width", 4)
        .style("stroke", colorScale(1))
    ;

    var hoverLink = link
        .append("line")
        .attr("stroke-width", 48)
        .style("stroke", "transparent")
    ;

    var node = svg
        .append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(nodesData)
        .enter()
        .append("g")
        .on('mouseover', fadeNode(0.5, 0.1, 0.5, 0.25, true))
        .on('mouseout', fadeNode(1.0, 1.0, 1.0, 1.0, false))
    ;

    node
        .append("circle")
        .attr("r", p => p.radius)
        .attr("fill", d => colorScale(d["referenced-n-times-local"]))
        .attr("stroke", "black")
        .attr("stroke-opacity", defaultStrokeOpacity)
        .style("filter", getFilter)
    ;

    node
        .append("circle")
        .attr("r", 150)
        .attr("fill-opacity", 0)
        .attr("stroke-opacity", 0)
    ;

    node
        .append("text")
        .attr("dx", 0)
        .attr("dy", d => d.radius + labelFontSizePixels + 4)
        .style("text-anchor", "middle")
        .style("font-size", labelFontSizeString)
        .style("font", "Roboto")
        .text(d => d.title.length > maxTitleLength ? d.title.substring(0, maxTitleLength) + "â€¦" : d.title)
        .style("opacity", defaultTextOpacity)
    ;

    function getFilter(d) {
        return makeFilter('drop-shadow-' + d["referenced-n-times-local"], false);
    }

    function getFilterSelected(d) {
        return makeFilter('drop-shadow-' + d["referenced-n-times-local"] + "-selected", true);
    }

    // https://stackoverflow.com/questions/33878292/d3-set-filter-flood-color-based-on-data
    function makeFilter(id, isSelected) {
        if (defs.selectAll("#" + id).empty()) {
            var filter = defs
                .append('filter')
                .attr('id', id)
                .attr('height', '200%')
            ;

            filter
                .append('feGaussianBlur')
                .attr('in', 'SourceAlpha')
                .attr('stdDeviation', isSelected ? 3 : 1)
                .attr('result', 'blur')
            ;

            filter
                .append('feOffset')
                .attr('in', 'blur')
                .attr('result', 'offsetBlur')
            ;

            filter
                .append("feFlood")
                .attr("in", "offsetBlur")
                .attr("flood-color", isSelected ? colorScale(100) : shadowColorScale(0))
                .attr("flood-opacity", "1")
                .attr("result", "offsetColor")
            ;

            filter
                .append("feComposite")
                .attr("in", "offsetColor")
                .attr("in2", "offsetBlur")
                .attr("operator", "in")
                .attr("result", "offsetBlur")
            ;

            var feMerge = filter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'offsetBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
        }
        return 'url(#' + id + ")"
    }

    function isConnected(a, b) {
        return linksData.some(function (l) {
            return a.key === b.key
                || (l.source.key === a.key && l.target.key === b.key)
                || (l.source.key === b.key && l.target.key === a.key);
        });
    }

    function isPartOfLink(n, l) {
        return n.key === l.source.key || n.key === l.target.key;
    }

    var hoverTransitionDuration = 250;
    var isDragging = false;

    // http://bl.ocks.org/martinjc/396926c15afa2ab0127322a01d97b5f4
    function fadeNode(fillOpacity, strokeOpacity, textOpacity, linkOpacity, isHoverMode) {
        return function (d) {
            if (isDragging) {
                return;
            }

            node
                .select("circle")
                .transition("fade")
                .duration(hoverTransitionDuration)
                .style("stroke-opacity", o => isConnected(d, o) ? 1 : strokeOpacity)
                .style("fill-opacity", o => isConnected(d, o) ? 1 : fillOpacity)
                .style("filter", function (o) {
                    if (isHoverMode) {
                        if (o.key === d.key) {
                            return getFilterSelected(o)
                        } else {
                            return isConnected(d, o) ? getFilter(o) : "";
                        }
                    } else {
                        return getFilter(o);
                    }
                })
            ;
            node
                .select("text")
                .transition("fade")
                .duration(hoverTransitionDuration)
                .style("opacity", o => isConnected(d, o) ? 1 : strokeOpacity)
            ;
            link
                .transition("fade")
                .duration(hoverTransitionDuration)
                .style("stroke-opacity", l => isPartOfLink(d, l) ? 1 : linkOpacity)
            ;
        };
    }

    function fadeLink(fillOpacity, strokeOpacity, textOpacity, linkOpacity, isHoverMode) {
        return function (l) {
            if (isDragging) {
                return;
            }

            node
                .select("circle")
                .transition("fade")
                .duration(hoverTransitionDuration)
                .style("stroke-opacity", o => isPartOfLink(o, l) ? 1 : strokeOpacity)
                .style("fill-opacity", o => isPartOfLink(o, l) ? 1 : fillOpacity)
                .style("filter", function (o) {
                    if (isHoverMode) {
                        return isPartOfLink(o, l) ? getFilterSelected(o) : "";
                    } else {
                        return getFilter(o);
                    }
                })
            ;
            node
                .select("text")
                .transition("fade")
                .duration(hoverTransitionDuration)
                .style("opacity", o => isPartOfLink(o, l) ? 1 : strokeOpacity)
            ;
            link
                .transition("fade")
                .duration(hoverTransitionDuration)
                .style("stroke-opacity",
                    l2 => isPartOfLink(l2.source, l) && isPartOfLink(l2.target, l) ? 1 : linkOpacity)
            ;
        };
    }

    force.on("tick", tickActions);

    function tickActions() {
        node
            .attr("cx", d => d.x = Math.max(d.radius, Math.min(width - d.radius, d.x)))
            .attr("cy", d => d.y = Math.max(d.radius + yearHeight * d.year,
                Math.min(yearHeight * (d.year + 1) - d.radius - labelFontSizePixels - 12, d.y)))
            .attr("transform", d => "translate(" + d.x + "," + d.y + ")")
        ;

        visibleLink
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y)
        ;

        hoverLink
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y)
        ;
    }

    var drag_handler = d3
        .drag()
        .on("start", drag_start)
        .on("drag", drag_drag)
        .on("end", drag_end);

    drag_handler(node);

    function drag_start(d) {
        if (!d3.event.active) {
            force.alphaTarget(0.3).restart();
        }
        isDragging = true;
        d.fx = d.x;
        d.fy = d.y;
    }

    function drag_drag(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function drag_end(d) {
        if (!d3.event.active) {
            force.alphaTarget(0);
        }
        isDragging = false;
        d.fx = null;
        d.fy = null;
    }
</script>
</body>
</html>
